= Developer Experience with Spring Cloud
Spencer Gibb, Dave Syer, 2015
:backend: deckjs
:deckjs_transition: fade
:navigation:
:menu:
:status:
:source-highlighter: pygments
:deckjs_theme: spring
:deckjsdir: ../deck.js

== Authors

Spencer Gibb, +
http://twitter.com/spencerbgibb[@spencerbgibb], +
sgibb@pivotal.io

Dave Syer, +
http://twitter.com/david_syer[@david_syer], +
dsyer@pivotal.io

== Lattice native discovery, Eureka

== Routing from lattice to IDE (ie local dev experience)

== Configuration models:

* flag to enable local route
* prefer route that “looks local”
* Flag a request (e.g. header with correlation ID)

== Stubbing

* Greenfield (dependent services don't exist yet, write stubs)
* Brownfield (dependent services exist and have published stubs)

== Stubbing Brownfield Services

* Create http://wiremock.org/stubbing.html[Wiremock] stubs using tests or dsl
** https://github.com/Codearte/accurest[AccuREST] uses a groovy dsl to create integration tests and stubs.
** https://github.com/spring-projects/spring-restdocs[Spring REST Docs] uses tests to generate snippets for documentation and can be used to create stubs.
* Run Wiremock using generated stubs
* Run consuming services against Wiremock stubs

== Stubbing: AccuREST DSL

Generates a MockMVC test and a Wiremock stub

[source,groovy]
----
import io.codearte.accurest.dsl.GroovyDsl

GroovyDsl groovyDsl = GroovyDsl.make {
    request {
        method 'GET'
        url '/foo'
    }
    response {
        status 200
        headers {
            header 'Content-Type' : 'application/json;charset=UTF-8'
        }
        body '''{ "value" : 42 }'''
    }
}
----

== Stubbing: Wiremock Stub

[source,json]
----
{
    "request": {
        "method": "GET",
        "url": "/foo"
    },
    "response": {
        "status": 200,
        "headers": {
            "Content-Type": "application/json;charset=UTF-8"
        },
        "body": "{\"value\":42}"
    }
}
----

== Stubbing: 4finance stubrunner

* Publish stub files to nexus repository (or local maven repo)
* Describe a services dependencies in `application.yml`
* Stubrunner using list of dependencies
** Grabs stubs from repository
** Runs a wiremock server for each dependency using fetched stubs
** Registers server in service discovery
* Consuming service can function against stubs *(DEMO)*

== Hot reloading

Hot reloading of “local” application code deployed on Cloud Foundry / Lattice

== ALM

how does new code enter a build pipeline and get promoted to production?

== Ability to debug http requests

* distributed tracing
* cf/lattice logs
* https://ngrok.com

== Docker volumes and database/middleware services

== Discovery and DI of database/middleware services

== Provisioning a system for testing

* Docker compose
* Locally with VirtualBox
* Remotely Lattice AWS, PCF, etc.
